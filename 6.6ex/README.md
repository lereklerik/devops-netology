# Домашнее задание к занятию "6.6. Troubleshooting"

## Задача 1

    Пользователь (разработчик) написал в канал поддержки, что у него уже 3 минуты происходит CRUD операция в MongoDB и её нужно прервать.    
    Вы как инженер поддержки решили произвести данную операцию:    
        -   напишите список операций, которые вы будете производить для остановки запроса пользователя
        -   предложите вариант решения проблемы с долгими (зависающими) запросами в MongoDB
---------------------------------------------------------------------
* Сначала необходимо определить, какую операцию выполнял пользователь, что привело к деградации производительности. Для этого необходимо обратиться к профилированию БД.
* Команда, которая возвращает отчет о `CRUD` операциях - `currentOp`:
* Посмотреть все операции:
```json
db.adminCommand(
   {
     currentOp: true,
     "$all": true
   }
)
```
* Посмотреть операции, ожидающие блокировки:
```json
db.adminCommand(
   {
     currentOp: true,
     "waitingForLock" : true,
     $or: [
        { "op" : { "$in" : [ "insert", "update", "remove" ] } },
        { "command.findandmodify": { $exists: true } }
    ]
   }
)
```
* Посмотреть операции, которые не привели к блокировкам, но и не закончились успешно:
```json
db.adminCommand(
   {
     currentOp: true,
     "active" : true,
     "numYields" : 0,
     "waitingForLock" : false
   }
)
```
* По выполнению этих операций получаем вывод в формате `bson`, из которого, в частности, можно извлечь информацию:
  * О пользователе, запустившим операцию; ключ `currentOp.runBy`, где могут быть перечислены имя пользователя и название БД.
  * О транзакции, которая не закончилась или привела к ошибкам; ключ `currentOp.transaction`
  * О номере операции, которую запустил пользователь; ключ `currentOp.opid`
  * О плане выполнения запроса, чтобы понять, какие коллекции или индексы участвовали в операции; ключ `currentOp.planSummary`
  * О возможных конфликтах с другими операциями; ключ `currentOp.writeConflicts`
  * О блокировках; ключ `currentOp.locks`
* Необходимо проанализировать отчет и делать определенные выводы.
---------------------------------------------------------------------

_На основании полученного идентификатора запроса по ключу `currentOp.opid` "убьем" процесс командой `db.killOp(opid)`, в параметры которого передадим полученный идентификатор._

_Вероятнее всего, долгое выполнение запроса является следствием отсутствия индексации или обусловлено необходимостью перестроить индексы._

---------------------------------------------------------------------

## Задача 2

    Вы запустили инстанс Redis для использования совместно с сервисом, который использует механизм TTL. 
    Причем отношение количества записанных key-value значений к количеству истёкших значений есть величина постоянная и увеличивается пропорционально количеству реплик сервиса.    
    При масштабировании сервиса до N реплик вы увидели, что:
      -    сначала рост отношения записанных значений к истекшим
      -    Redis блокирует операции записи
    Как вы думаете, в чем может быть проблема?

---------------------------------------------------------------------

* Проблема связана с истечением срока действия ключей событий.
* Удаление ключей с истекшим сроком в `redis` осуществляется двумя способами:
  * Ленивым способом, когда к ключу обращается процесс, и выясняется, что его срок действия истёк;
  * Активным способом, когда срок действия ключей истекает каждые 100 мс (10 раз в секунду)

* Во втором случае в цикле выполняются следующие действия:
  * В опции `ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP` указывается количество ключей, которые должны быть удалены в активном режиме. Они удаляются. По умолчанию, это значение равно 20;
  * Когда ключей с истекшим сроком действия больше 25% от общего числа, цикл повторяется.

* Однако алгоритм будет зацикливаться, если обнаружит, что более 25% в выбранном наборе с `ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP` уже просрочены.
* Учитывая, что запускается алгоритм 10 раз в секунду, то каждая такая секунда работы механизма удаления ключей будет заканчиваться неудачно.
* Т.е. если в БД много ключей, срок действия которых истекает за одну секунду, и они составляют не менее 25% от текущей совокупности ключей, 
  Redis может заблокировать дальнейшие операции записи, чтоб получить оставшийся список ключей с истекшим сроком действия для удаления.
* Данная блокировка необходима, чтоб избежать использования памяти ключами, срок действия которых истек. 

_Такая ситуация часто возникает, если в опции `EXPIREAT` некорректно указана временная метка Unix, или ресурсы памяти уже исчерпаны._

---------------------------------------------------------------------

## Задача 3

    Вы подняли базу данных MySQL для использования в гис-системе. При росте количества записей, в таблицах базы, пользователи начали жаловаться на ошибки вида:
```properties
InterfaceError: (InterfaceError) 2013: Lost connection to MySQL server during query u'SELECT..... '
```
    Как вы думаете, почему это начало происходить и как локализовать проблему?
    Какие пути решения данной проблемы вы можете предложить?

---------------------------------------------------------------------

* Согласно документации, ошибка может возникать по трём причинам:
1. **Проблемы с подключением к сети**. Появление такой ошибки во время выполнения запроса говорит о том, что данные не могут быть корректно переданы. Для этого предлагается увеличить значение свойства `net_read_timeout`, чтобы передача данных завершалась успешно.
2. **Проблемы начального соединение клиента с сервером**. В этом случае можно увеличить значение свойства `connect_timeout` на то количество секунд, сколько требуется для успешного соединения в сети. Дополнительно можно запросить статистику неудачных соединений командой `SHOW GLOBAL STATUS LIKE 'Aborted_connects'`. Если в сообщениях будет присутствовать фраза `reading authorization packet`, то решение с `connect_timeout` должно помочь.
3. **Проблемы с `BLOB`-значениями**. В данном случае, `BLOB`-значения могут превышать максимальное значение свойства `max_allowed_packet`. Иногда ошибка сопровождается дополнительной - `ER_NET_PACKET_TOO_LARGE`. В таком случае необходимо увеличить значение свойства `max_allowed_packet` до приемлемого.


---------------------------------------------------------------------

## Задача 4

    Вы решили перевести гис-систему из задачи 3 на PostgreSQL, так как прочитали в документации, что эта СУБД работает с большим объемом данных лучше, чем MySQL.
    После запуска пользователи начали жаловаться, что СУБД время от времени становится недоступной. В dmesg вы видите, что:
`postmaster invoked oom-killer`
    
    Как вы думаете, что происходит?
    Как бы вы решили данную проблему?
---------------------------------------------------------------------

* Ошибка возникает при нехватке памяти. В этом случае система завершает процесс PostgreSQL, съедающий всю память, чтобы не обрушить саму систему. 
* `Out-Of-Memory Killer` — это процесс, который завершает приложение, чтобы спасти ядро от сбоя.
* Самым логичным решением этой проблемы является увеличение объема оперативной памяти.
* Однако, память так и будет заканчиваться, если не ограничить в приложении использование ресурсов хоста, на котором оно запущено. Для этого можно настроить следующие параметры в конфигурации приложения:
  * `shared_buffer` - размер выделенной памяти PostgreSQL для кэширования (обычно 25% от используемой памяти);
  * `wal_buffers` - размер буфера журнала перезаписи;
  * `effective_cache_size` - оценка памяти, доступной для кэширования диска;
  * `work_mem` - настройка сложной сортировки; рекомендуется изменение на уровне сеанса пользователя (глобальное применение приводит к потере памяти при большом количестве пользователей);
  * `maintenance_work_mem` - параметр памяти, используемый для задач обслуживания.