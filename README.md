# Домашнее задание к занятию "3.6. Компьютерные сети, лекция 1"

## 1. Необязательное задание: можно посмотреть целый фильм в консоли telnet towel.blinkenlights.nl :)

*   Увы, не telnet'ится

```shell
~$ nmap towel.blinkenlights.nl

Starting Nmap 7.60 ( https://nmap.org ) at 2021-06-21 22:13 MSK
Nmap scan report for towel.blinkenlights.nl (213.136.8.188)
Host is up (0.052s latency).
Other addresses for towel.blinkenlights.nl (not scanned): 2001:7b8:666:ffff::1:42
Not shown: 999 closed ports
PORT   STATE    SERVICE
23/tcp filtered telnet

Nmap done: 1 IP address (1 host up) scanned in 1.97 seconds
~$ telnet towel.blinkenlights.nl 23
Trying 213.136.8.188...
Trying 2001:7b8:666:ffff::1:42...
telnet: Unable to connect to remote host: Network is unreachable
```
*   Но посмотрела на ютубе) Классно, спасибо!

## 2. Узнайте о том, сколько действительно независимых (не пересекающихся) каналов есть в разделяемой среде WiFi при работе на 2.4 ГГц. Стандарты с полосой 5 ГГц более актуальны, но регламенты на 5 ГГц существенно различаются в разных странах, а так же не раз обновлялись. В качестве дополнительного вопроса вне зачета, попробуйте найти актуальный ответ и на этот вопрос.

###   Диапазон 2,4 ГГц
    Основным регламентирующим документом в России является Постановление Правительства РФ от 12.10.2004 N 539 (ред. от 22.12.2018) 
    "О порядке регистрации радиоэлектронных средств и высокочастотных устройств", а именно пункт 24, который гласит, что не подлежат регистрации:
    Устройства малого радиуса действия, используемые в сетях беспроводной передачи данных, и другие устройства с функцией передачи данных в полосе 
    радиочастот 2400 - 2483,5 МГц, с прямым расширением спектра и другими видами модуляции с максимальной эквивалентной изотропно-излучаемой 
    мощностью не более 100 мВт
    
*   Разрешенный в России диапазон включает в себя 13 каналов шириной в 20 МГц и частотным шагом в 5 МГц.

```shell
:~$ iwlist wlo1 channel
wlo1      29 channels in total; available frequencies :
          Channel 01 : 2.412 GHz
          Channel 02 : 2.417 GHz
          Channel 03 : 2.422 GHz
          Channel 04 : 2.427 GHz
          Channel 05 : 2.432 GHz
          Channel 06 : 2.437 GHz
          Channel 07 : 2.442 GHz
          Channel 08 : 2.447 GHz
          Channel 09 : 2.452 GHz
          Channel 10 : 2.457 GHz
          Channel 11 : 2.462 GHz
          Channel 12 : 2.467 GHz
          Channel 13 : 2.472 GHz
```
*  Из них независимыми или непересекающимися являются только три канала: 1-й, 6-й и 11-й. 

### Диапазон 5 ГГц

    Для решения проблемы загруженности диапазона 2,4 ГГц для Wi-Fi устройств был дополнительно выделен диапазон 
    5 ГГц, точнее ряд диапазонов в полосе частот 5-6 ГГц. 
    
    В России данный диапазон регулируется пунктом 23 указанного выше Постановления, который выводит из под 
    регистрации:
    Устройства малого радиуса действия в сетях беспроводной передачи данных и другие устройства с функцией 
    передачи данных с прямым расширением спектра и другими видами модуляции, используемые внутри закрытых 
    помещений в полосах радиочастот 5150 - 5350 МГц, 5650 - 5850 МГц с максимальной эквивалентной изотропно-излучаемой 
    мощностью не более 200 мВт.

    5 ГГц - это не единый диапазон, а целый ряд диапазонов, порядок использования которых в различных странах может отличаться. 

[схема распределения каналов](https://bikepower.ddns.net/index.php/s/SApPzNnrFaAqLqG)    

    Частотная сетка диапазона предусматривает использования для Wi-Fi только непересекающихся каналов шириной 20 МГц и с шагом 20 МГц, 
    от начала и конца полосы частотный отступ составляет 30 МГц. Первоначально были разрешены к использованию полосы UNII-1 (Европа, Россия) 
    и дополнительно к ней UNII-3 и один канал из "медицинского" ISM (США), позднее к ним добавили полосу UNII-2.

```shell
~$ iwlist wlo1 channel
wlo1      29 channels in total; available frequencies :
...
          Channel 36 : 5.18 GHz
          Channel 40 : 5.2 GHz
          Channel 44 : 5.22 GHz
          Channel 48 : 5.24 GHz
          Channel 52 : 5.26 GHz
          Channel 56 : 5.28 GHz
          Channel 60 : 5.3 GHz
          Channel 64 : 5.32 GHz
          Channel 132 : 5.66 GHz
          Channel 136 : 5.68 GHz
          Channel 140 : 5.7 GHz
          Channel 149 : 5.745 GHz
          Channel 153 : 5.765 GHz
          Channel 157 : 5.785 GHz
          Channel 161 : 5.805 GHz
          Channel 165 : 5.825 GHz
          Current Frequency:2.447 GHz (Channel 8)
```
## 3. Адрес канального уровня – MAC адрес – это 6 байт, первые 3 из которых называются OUI – Organizationally Unique Identifier или уникальный идентификатор организации. Какому производителю принадлежит MAC 38:f9:d3:55:55:79?

*   Скачала базу производителей и MAC-адресов:
```shell
wget http://standards-oui.ieee.org/oui/oui.txt
```
*   Добавила скрипт
```shell
#!/bin/bash
  
MAC="$(echo $1 | sed 's/ //g' | sed 's/-//g' | sed 's/://g' | cut -c1-6)";
 
result="$(grep -i -A 4 ^$MAC ./oui.txt)";
 
if [ "$result" ]; then
    echo "Для MAC $1 найдена следующая информация:"
    echo "$result"
else
    echo "MAC $1 не найден в базе данных."
fi
```
*    и запустила поиск по MAC-адресу:
```shell
~$ chmod +x oui.sh
~$ sudo ./oui.sh 38:f9:d3:55:55:79
Для MAC 38:f9:d3:55:55:79 найдена следующая информация:
38F9D3     (base 16)		Apple, Inc.
				1 Infinite Loop
				Cupertino  CA  95014
				US
```
*   MAC-адрес принадлежит компании *Apple*

## 4. Каким будет payload TCP сегмента, если Ethernet MTU задан в 9001 байт, размер заголовков IPv4 – 20 байт, а TCP – 32 байта?

*   MSS (Maximum Segment Size) – размер полезных данных (payload) в одном сегменте 
    (MTU минус заголовки TCP, минус заголовки IP)
        
        Таким образом, payload = 9001 - (20 + 32)
        MSS = 8949

## 5. Может ли во флагах TCP одновременно быть установлены флаги SYN и FIN при штатном режиме работы сети? Почему да или нет?

*   SYN (1 бит). Начинает соединение и синхронизирует порядковые номера. Первый пакет, отправленный с каждой стороны, должен в обязательном порядке иметь установленным этот флаг.
*   FIN (1 бит). Одна из конечных точек отправляет пакет с установленным флагом FIN для другой конечной точки, чтобы сообщить, что все пакеты были отправлены, и соединение пора завершить.

        Комбинация флага SYN и FIN, устанавливаемого в заголовке TCP, является недопустимой, 
        поскольку она требует как установления соединения (через SYN), так и прекращения соединения (через FIN).

## 6. `ss -ula sport = :53` на хосте имеет следующий вывод:
```shell
State           Recv-Q          Send-Q                   Local Address:Port                     Peer Address:Port          Process
UNCONN          0               0                        127.0.0.53%lo:domain                        0.0.0.0:*
```
## Почему в State присутствует только UNCONN, и может ли там присутствовать, например, TIME-WAIT?

*   т.к. в команде присутствует опция `-u`, то информация выводится по протоколу UDP
    > User Datagram Protocol (UDP) — это простой, ориентированный на дейтаграммы протокол 
    без организации соединения, предоставляющий быстрое, но необязательно надежное транспортное обслуживание.
*   UDP не требует подтверждения соединения, доставки пакетов и не повторяет передачу потерянных сегментов. 
    Передавая данные по UPD датаграммы могут приходить не по порядку и даже дублироваться, а иногда и просто 
    пропадать. Таким образом, "механизм" синхронизации у него также отсутствует. 
    UDP для разрыва соединения не нужно ждать завершения сессии.
    
*   `UNCONN` - говорит нам о том, что соединение не установлено, что в целом, отвечает работе протокола UDP
*   `TIME_WAIT` - это ожидания доставки сообщения подтверждения о завершении сессии. Как было написано выше, UDP
    не требует подтверждений, поэтому для этого протокола статус `TIME_WAIT` излишен.
    
## 7. Обладая знаниями о том, как штатным образом завершается соединение (FIN от инициатора, FIN-ACK от ответчика, ACK от инициатора), опишите в каких состояниях будет находиться TCP соединение в каждый момент времени на клиенте и на сервере при завершении. Схема переходов состояния соединения вам в этом поможет.

*   Соединение `TCP` переходит с одного состояния на другое в ответ на события. 
    Событие -- это запросы клиента (открытие, посылка, получение, закрытие, отказ, получение состояния соединения), приход сегментов, и особенно тех, которые содержат флаги SYN, ACK, RST и FIN, а также истечение выделенного времени.
    
    *   Сначала соединение находится в статусе *ESTABLISHED* - установлено
    *   Затем, сервер отправляет запрос на закрытие соединение клиентской стороне и переходит в статус *FIN-WAIT-1* 
        >`FIN-WAIT-1`	Ожидание запроса от чужой программы TCP, или подтверждения ранее отправленного запроса на закрытие соединения.
    *   Клиент получает запрос на закрытие и отправляет подтверждение о закрытии, переходит в статус *CLOSE-WAIT*
        >`CLOSE-WAIT`	Ожидание запроса на закрытие соединения со стороны своего клиента.
    *   Сервер получает подтверждение и переходит в статус *FIN-WAIT-2*
        >`FIN-WAIT-2`	Ожидание запроса на закрытие соединения со стороны чужой программы TCP.
    *   Затем клиент переходит в состояние ожидания последнего подтверждения *LAST-ACK*
        >`LAST-ACK` 	Ожидание запроса на закрытие соединения, ранее отправленного чужой программе TCP (запрос включал также подтверждение получения чужого запроса на закрытие соединения)
    *   Сервер отправляет последнее подтверждение *LAST-ACK* и переходит в состояние *TIME-WAIT*, в котором клиенты не обслуживает
        >`TIME-WAIT`    Ожидание когда истечет достаточное количество времени и можно быть уверенным, что чужая программа TCP получила подтверждение своего запроса на закрытие соединения.
    *   Клиент переходит в состояние *CLOSED*
        >`CLOSED`       Состояние полного отсутствия соединения.
    *   По истечению времени сервер также переходит в состояние полного отсутствия соединения *CLOSED* 


 | №  | Инициатор закрытия (сервер)                    | Действие              | Сторона клиента                                    |
 |---:|:-----------------------------------------------|:---------------------:|:--------------------------------------------------:|
 |  1 | *ESTABLISHED*                                  |                       | *ESTABLISHED*                                      |   
 |  2 | ===> Закрытие соединения (*FIN-WAIT-1*)        |   FIN  ===>           | ===> Получен FIN                                   |   
 |  3 | Получено подтверждение(*FIN-WAIT-2*) <===      |        <=== ACK       | Отправляем подтверждение (*CLOSE-WAIT*)  <===      | 
 |  4 | Получаем FIN  <===                             |        <=== FIN       | Ожидание последнего подтверждения (*LAST-ACK*) <===|
 |  5 | ===> Отправляем последний ACK                  |    ACK  ===>          | ===> *CLOSED*                                      |
 |  6 | Ждем возможные потерянные данные (*TIME-WAIT*) |                       |                                                    |
 |  7 | ...                                            |                       |                                                    |
 |  8 | *CLOSED*                                       |                       |                                                    |

## 8. TCP порт – 16 битное число. Предположим, 2 находящихся в одной сети хоста устанавливают между собой соединения. Каким будет теоретическое максимальное число соединений, ограниченное только лишь параметрами L4, которое параллельно может установить клиент с одного IP адреса к серверу с одним IP адресом? Сколько соединений сможет обслужить сервер от одного клиента? А если клиентов больше одного?    
*   `L4` - Балансировка на транспортном уровне (**L4**) - Это самый универсальный и распространенный механизм. 
    Одинаково применим для TCP и UDP протоколов, а соответственно им можно распределять трафик практически любого сервиса. 
    На этом уровне во входящих пакетах проверяется лишь IP-адрес и номер порта назначения.
    

=======================>
*   **UPD**
-----------------------------------------
*   Каждый хост ограничен своими ресурсами: памятью, процессором и т.д.
*   Теоретически, сколько неиспользуемых портов имеет машина, столько TCP-соединений может быть инициализировано извне.
*   В нашем примере, клиент устанавливает TCP-соединение (16 бит). Всего, получается, имеется локальных портов 0-65535, из которых 0 ~ 1023 
    являются зарезервированными портами (0 - не может использоваться, следующие доступны супер-администраторам). Поэтому теоретически портов - 65535 (отбросив уже используемые или зарезервированные под другие задачи, и если учитывать, что мы супер-администраторы). 
*   Каждый пакет TCP/IP идентифицируется четырьмя параметрами, которые внутри стека TCP используются в качестве составного ключа для сопоставления пакетов с соединениями:
            `*IP локальный:PORT локальный IP удаленный: PORT удаленный*`
*   Что теоретически говорит о том, что максимальное число клиентов = 65535 и с каждым может быть установлено 65535 соединений
*   **НО!** Каждому сокету присваивается свой файловый дескриптор, а их количество всегда ограничено. Поэтому пределом является количество файловых дескрипторов, 
    разрешенных системой, и ресурсов для обработки. 

*Ответ:*
**В реальной среде из-за физических условий, таких как конфигурация сервера, максимальное количество одновременных TCP-соединений 
не может достичь теоретического значения (65535), кроме как за счет увеличения памяти, изменения максимального количества файловых дескрипторов и других настроек конфигурации.**

-----------------------------------------
<=======================


 ~~Теоретическое максимальное количество портов **< 2^16**, а значит = **65535**~~
 ~~Соответственно, теоретически, сервер может принять 65535 соединений, для каждого из которых будет выделен один порт~~ 
    
*  **L4** выполняет простую проверку доступности адреса и порта. В случае если порт открыт, сервер считается доступным и к нему продолжают отправляться запросы.
*   Каждому отдельному сокету присваивается файловый дескриптор, поэтому пределом, на самом деле, является **количество файловых дескрипторов**, разрешенных системой, и ресурсов для обработки.

## 9. Может ли сложиться ситуация, при которой большое число соединений TCP на хосте находятся в состоянии TIME-WAIT? Если да, то является ли она хорошей или плохой? Подкрепите свой ответ пояснением той или иной оценки.

*   `TIME-WAIT`    Ожидание когда истечет достаточное количество времени и можно быть уверенным, что чужая программа TCP получила подтверждение своего запроса на закрытие соединения.
*   Состояние `TIME-WAIT` в протоколе TCP позволяет системе убедиться в том, что в данном TCP-соединении действительно прекращена передача данных и никакие данные не были потеряны. 
    Однако, одновременно открытых сокетов может быть ровно столько, сколько позволят создать ресурсы сервера. И в этом состоянии не выполняется обслуживание клиента.
    
`Проблема TIME_WAIT для исходящих соединений`
*   Каждый пакет TCP/IP идентифицируется четырьмя параметрами::
    `*IP локальный:PORT локальный IP удаленный: PORT удаленный*`
*   Клиент активно подключается/отключается к удаленной службе. Поскольку оба IP и удаленный порт остаются неизменными, то на каждое новое соединение выделяется новый локальный порт. 
*   Если клиент был активной стороной завершения TCP-сессии, то это соединение будет заблокировано какое-то время в состоянии `TIME_WAIT`.
*   Если соединения устанавливаются быстрее чем порты выходят из `TIME_WAIT`, то при очередной попытке соединения клиент получит ошибку.
*   Даже если приложения обращаются к разным службам, и ошибка не происходит, очередь `TIME_WAIT` будет расти, забирая системные ресурсы. 
    
`TIME_WAIT на серверах`

*   Главная опасность которою несет разрастание очереди `TIME_WAIT` на сервере — это исчерпание ресурсов.
*   Тем не менее могут быть неприятные инциденты, когда за одним IP находятся большое количество клиентов сервера. 
*   В случае малого значения времени `TIME_WAIT` порта на Firewall велика вероятность, что к серверу придёт запрос соединения с того же порта, 
    соединение с которым ещё не закрыто (находится в TIME_WAIT). В этом случае возможно:
    > (Маловероятный) клиент угадает номер последовательности, что крайне маловероятно. В этом случае поведение не определено;
    
    > Клиент отравит пакет с некорректным (с точки зрения сервера номером последовательности), на что сервер ответит ему последним ACK-пакетом, который будет уже не понятен клиенту.

Думаю, что ситуация не критичная до определенных моментов: пока сервисы не разрослись, клиентов много не появилось - всё крайне спокойно.
Но если сеть расширяется, то это может привести к тем ситуациям, которые описаны выше. В таких случаях требуется тонкая настройка системы.
    
 
## 10. Чем особенно плоха фрагментация UDP относительно фрагментации TCP?

*   **Отсутствие сигналов квитирования.** 
    *   Перед отправкой пакета UDP, отправляющая сторона не обменивается с получающей стороной квитирующими сигналами. 
    *   Следовательно, у отправителя нет способа узнать, достигла ли дейтаграмма конечной системы. 
    *   В результате UDP не может гарантировать, что данные будут действительно доставлены адресату.

*   **Использование сессий.** UDP не имеет поддержки сеансов из-за своей природы, не ориентированной на соединения.
  
*   **Надежность.** UDP не гарантирует, что адресату будет доставлена только одна копия данных. 
    Чтобы отправить конечной системе большой объем данных, UDP разбивает его на небольшие части. 
    UDP не гарантирует, что эти части будут доставлены по назначению в том же порядке, в каком они создавались в источнике. 

*   **Безопасность.** TCP более защищен, чем UDP. Во многих организациях брандмауэры и маршрутизаторы не пропускают пакеты UDP. 
    Это связано с тем, что хакеры могут воспользоваться портами UDP, не устанавливая явных соединений.

*   **Управление потоком.** В UDP управление потоком отсутствует, в результате плохо спроектированное UDP-приложение 
    может захватить значительную часть пропускной способности сети.

## 11. Если бы вы строили систему удаленного сбора логов, то есть систему, в которой несколько хостов отправяют на центральный узел генерируемые приложениями логи (предположим, что логи – текстовая информация), какой протокол транспортного уровня вы выбрали бы и почему? Проверьте ваше предположение самостоятельно, узнав о стандартном протоколе syslog.

*   Учитывая ответ на предыдущий вопрос, то я бы использовала TCP-протокол:
    
>*Протокол TCP ориентирован на установление соединений и обеспечивает взаимодействие между подключенными к сети хостами, используя пакеты. В TCP применяются сигналы квитирования, позволяющие проверить успешность транспортировки данных.*; 
    
>*Ориентированность TCP на соединения поддерживается сеансами между хостами. TCP использует идентификатор сеанса, позволяющий отслеживать соединения между двумя хостами.*;

>*TCP вместе с номерами портов использует порядковые номера и регулярно отправляемые подтверждения, гарантирующие упорядоченную доставку данных.*


*   `Syslog` - стандартом предусматривается, что источники формируют простые текстовые сообщения о происходящих в них событиях и передают их на обработку серверу Syslog, используя один из сетевых протоколов семейства IP **UDP или TCP.** 
    >   С выходом в августе 2001 года RFC 3164 «The BSD Syslog Protocol» (Протокол BSD Syslog) в качестве транспортного механизма был заявлен **UDP** (порт 514) из семейства IPv4, а также введены некоторые ограничения, связанные с использованием данного транспорта.
    
    >   В ноябре 2001 года вышел RFC 3195 «Reliable Delivery for Syslog» (Гарантированная доставка для Syslog), в котором предлагалось решение, позволяющее повысить надежность протокола Syslog за счет применения определённой реализации каркасов BEEP[3] в качестве носителя сообщений и использования **TCP** (порт 601) из семейства IPv4 в качестве транспорта.
    
    >  RFC 5425 «Transport Layer Security (TLS) Transport Mapping for Syslog» (Механизм доставки для Syslog, обеспечивающий безопасность на транспортном уровне (TLS)) описал применение механизма TLS для доставки сообщений с использованием **TCP** (порт 6514) из семейства IPv4/v6 в качестве транспорта, его ограничения и проблемы безопасности.
    
    >   В октябре 2010 года вышел RFC 6012 «Datagram Transport Layer Security (DTLS) Transport Mapping for Syslog» (Механизм доставки для Syslog, обеспечивающий безопасность датаграмм на транспортном уровне (DTLS)), предложивший применение механизма TLS для доставки сообщений с использованием **UDP** (порт 6514) из семейства IPv4/v6 в качестве транспорта, его ограничения и проблемы безопасности.
    
    >   Вышедший в апреле 2012 года RFC 6587 «Transmission of Syslog Messages over TCP» (Передача сообщений Syslog через TCP) описал сложившиеся механизмы доставки сообщений, не использующие TLS, посредством TCP из семейства IPv4/v6 в качестве транспорта, их ограничения и проблемы безопасности.

## 12. Сколько портов TCP находится в состоянии прослушивания на вашей виртуальной машине с Ubuntu, и каким процессам они принадлежат?

*   По `udp` прослушиваются 4 порта (3 iPv4, 1 iPv6), по `tcp` 5 портов (3 iPv4, 2 iPv6)
```shell
vagrant@vagrant:~$ sudo ss -tulnp
Netid              State               Recv-Q              Send-Q                            Local Address:Port                           Peer Address:Port             Process                                                               
udp                UNCONN              0                   0                                       0.0.0.0:111                                 0.0.0.0:*                 users:(("rpcbind",pid=595,fd=5),("systemd",pid=1,fd=36))             
udp                UNCONN              0                   0                                 127.0.0.53%lo:53                                  0.0.0.0:*                 users:(("systemd-resolve",pid=596,fd=12))                            
udp                UNCONN              0                   0                                10.0.2.15%eth0:68                                  0.0.0.0:*                 users:(("systemd-network",pid=394,fd=19))                            
udp                UNCONN              0                   0                                          [::]:111                                    [::]:*                 users:(("rpcbind",pid=595,fd=7),("systemd",pid=1,fd=38))             
tcp                LISTEN              0                   4096                                    0.0.0.0:111                                 0.0.0.0:*                 users:(("rpcbind",pid=595,fd=4),("systemd",pid=1,fd=35))             
tcp                LISTEN              0                   4096                              127.0.0.53%lo:53                                  0.0.0.0:*                 users:(("systemd-resolve",pid=596,fd=13))                            
tcp                LISTEN              0                   128                                     0.0.0.0:22                                  0.0.0.0:*                 users:(("sshd",pid=1016,fd=3))                                       
tcp                LISTEN              0                   4096                                       [::]:111                                    [::]:*                 users:(("rpcbind",pid=595,fd=6),("systemd",pid=1,fd=37))             
tcp                LISTEN              0                   128                                        [::]:22                                     [::]:*                 users:(("sshd",pid=1016,fd=4))                                            
```
Процессы, помимо `systemd`:
```shell
vagrant@vagrant:~$ ps --pid 596 394 1016
    PID TTY      STAT   TIME COMMAND
    394 ?        Ss     0:00 /lib/systemd/systemd-networkd ## системный демон для управления сетевыми настройками
    596 ?        Ss     0:00 /lib/systemd/systemd-resolved ## служба systemd, выполняющая разрешение сетевых имён для локальных приложений посредством D-Bus, NSS-службы resolve (см. nss-resolve(8)) или локальной слушающей DNS-заглушки на адресе 127.0.0.53
   1016 ?        Ss     0:00 sshd: /usr/sbin/sshd -D [listener] 0 of 10-100 startups ##  служба, принимающая запросы на соединения от клиентов.
```

## 13. Какой ключ нужно добавить в tcpdump, чтобы он начал выводить не только заголовки, но и содержимое фреймов в текстовом виде? А в текстовом и шестнадцатиричном?

*   Попытка вывести информацию с `tcpdump` в кодировке ASCII в vagrant:
```shell
vagrant@vagrant:~$ sudo tcpdump -A -c 2
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth0, link-type EN10MB (Ethernet), capture size 262144 bytes
12:36:02.494137 IP 10.0.2.15.ssh > 10.0.2.2.59406: Flags [P.], seq 3179980324:3179980360, ack 3937487, win 63920, length 36
E..L..@.@..	
...
..........$.<..P....O....).N..f.......A&.U....Y3.4g.g..Yp$F
12:36:02.494215 IP 10.0.2.15.ssh > 10.0.2.2.59406: Flags [P.], seq 36:108, ack 1, win 63920, length 72
E..p..@.@.~.
...
..........H.<..P....s..{.N..ok?Q.X.
...}.Y....L...I.O. ....1...+...D.....R... B`.J.....{....,./
2 packets captured
38 packets received by filter
4 packets dropped by kernel
```
*   Текстовый и шестнадцатиричный формат:
```shell
vagrant@vagrant:~$ sudo tcpdump -X -c 2
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth0, link-type EN10MB (Ethernet), capture size 262144 bytes
12:40:23.281193 IP 10.0.2.15.ssh > 10.0.2.2.59406: Flags [P.], seq 3179981980:3179982016, ack 3937883, win 63920, length 36
	0x0000:  4510 004c a3ab 4000 4006 7ee0 0a00 020f  E..L..@.@.~.....
	0x0010:  0a00 0202 0016 e80e bd8a ac9c 003c 165b  .............<.[
	0x0020:  5018 f9b0 184f 0000 aa8e 1e46 f444 c564  P....O.....F.D.d
	0x0030:  238c 792e c093 d4d5 7375 b0e4 0618 4668  #.y.....su....Fh
	0x0040:  65c7 e28d 0642 29c1 976b 7f48            e....B)..k.H
12:40:23.281279 IP 10.0.2.15.ssh > 10.0.2.2.59406: Flags [P.], seq 36:108, ack 1, win 63920, length 72
	0x0000:  4510 0070 a3ac 4000 4006 7ebb 0a00 020f  E..p..@.@.~.....
	0x0010:  0a00 0202 0016 e80e bd8a acc0 003c 165b  .............<.[
	0x0020:  5018 f9b0 1873 0000 6289 8921 4f15 d1ae  P....s..b..!O...
	0x0030:  ef1e 7d9d 24f8 3d46 446a 714d 1358 a806  ..}.$.=FDjqM.X..
	0x0040:  5957 6ba7 d1d9 8e6a 6609 f905 0f94 baf2  YWk....jf.......
	0x0050:  b988 9f94 7b82 e97f a911 25c9 9ac2 e115  ....{.....%.....
	0x0060:  2884 fae0 b384 0b54 7ad0 955f 2c48 ff3d  (......Tz.._,H.=
2 packets captured
72 packets received by filter
39 packets dropped by kernel
```

## 14. Попробуйте собрать дамп трафика с помощью tcpdump на основном интерфейсе вашей виртуальной машины и посмотреть его через tshark или Wireshark (можно ограничить число пакетов -c 100). Встретились ли вам какие-то установленные флаги Internet Protocol (не флаги TCP, а флаги IP)? Узнайте, какие флаги бывают. Как на самом деле называется стандарт Ethernet, фреймы которого попали в ваш дамп? Можно ли где-то в дампе увидеть OUI?

Флаги и Идентификатор относятся к заголовкам IP-пакета.
*   **Идентификатор**	содержит уникальное целое число, идентифицирующее дейтаграмму.
*   **Флаги** - это поле в сочетании с полем Идентификатор предназначено для управления фрагментацией дейтаграммы. В поле Флаги фрагментации указывается, допустима ли фрагментация дейтаграммы, а также является ли данный фрагмент последним.

*   3 бита флагов. 
    *   Первый бит должен быть всегда равен нулю; 
    *   Второй бит DF (don’t fragment) определяет возможность фрагментации пакета
    *   Третий бит MF (more fragments) показывает, не является ли этот пакет последним в цепочке пакетов. 
        
> Бит 0 поля флаги является резервным, бит 1 служит для управления фрагментацией пакетов (0 - фрагментация разрешена; 1 - запрещена), бит 2 определяет, является ли данный фрагмент последним (0 - последний фрагмент; 1 - следует ожидать продолжения).  
*   Собрала tcpdump на своем хосте (Linux Mint):
```shell
~$ sudo tcpdump -i any port 443 -w exnetology.pcap
tcpdump: listening on any, link-type LINUX_SLL (Linux cooked), capture size 262144 bytes
^C1115 packets captured
1115 packets received by filter
0 packets dropped by kernel
```
Примеры с флагами:

```shell
Internet Protocol Version 4, Src: 96.16.164.192, Dst: 192.168.1.6
    0100 .... = Version: 4
    .... 0101 = Header Length: 20 bytes (5)
    Differentiated Services Field: 0x20 (DSCP: CS1, ECN: Not-ECT)
        0010 00.. = Differentiated Services Codepoint: Class Selector 1 (8)
        .... ..00 = Explicit Congestion Notification: Not ECN-Capable Transport (0)
    Total Length: 52
    Identification: 0xa1c4 (41412)
    ##
    ## (запрещена фрагментация, последний фрагмент)
    Flags: 0x4000, Don't fragment
        0... .... .... .... = Reserved bit: Not set
        .1.. .... .... .... = Don't fragment: Set
        ..0. .... .... .... = More fragments: Not set
    ##
    ##    
        ...0 0000 0000 0000 = Fragment offset: 0
    Time to live: 53
    Protocol: TCP (6)
    Header checksum: 0xdd60 [validation disabled]
    [Header checksum status: Unverified]
    Source: 96.16.164.192
    Destination: 192.168.1.6
```
Пример фрейма:
```shell
Frame 1115: 68 bytes on wire (544 bits), 68 bytes captured (544 bits)
    Encapsulation type: Linux cooked-mode capture (25)
    Arrival Time: Jun 24, 2021 16:00:28.608056000 MSK
    [Time shift for this packet: 0.000000000 seconds]
    Epoch Time: 1624539628.608056000 seconds
    [Time delta from previous captured frame: 0.038908000 seconds]
    [Time delta from previous displayed frame: 0.038908000 seconds]
    [Time since reference or first frame: 7.552895000 seconds]
    Frame Number: 1115
    Frame Length: 68 bytes (544 bits)
    Capture Length: 68 bytes (544 bits)
    [Frame is marked: False]
    [Frame is ignored: False]
    [Protocols in frame: sll:ethertype:ip:tcp]
Linux cooked capture
    Packet type: Unicast to us (0)
    Link-layer address type: 1
    Link-layer address length: 6
    Source: 98:00:6a:7c:ae:c6 (98:00:6a:7c:ae:c6)
    Unused: 0000
    ## Ethernet-II
    Protocol: IPv4 (0x0800)
```
Заголовок кадра относится к стандарту `Ethernet-II`

По стандарту Ethernet-II, заголовок кадра выглядит так:

| адрес получателя | адрес отправителя | тип "вложенного" пакета | 
|-----------------:|:-----------------:|:-----------------------:|
|   6 байт         |     6 байт        |      2 байта            |

"Тип пакета" в стандарте Ethernet-II - это стандартный номер, присвоенный протоколам более высокого уровня. Например, IP имеет номер 0x0800, что видно в фрейме.

*   **OUI** - уникальный идентификатор организации. Обычно идентификаторы UOI представлены в виде последовательности октетов, записанных одиночными
    парами или квартетами шестнадцатиричных цифр, разделенных знаками:
    *   45-67-89-AB-CD-EF (каноническа запись)
    *   45:67:89:AB:CD:EF (двоеточие или бит-реверсивной (неканонической) записи)
    *   45,67,89,AB,CD,EF (запятами)
    *   4567.89AB.CDEF  (точками квартетами в CISCO)
    *   456789ABCDEF (как шестнадцатиричное число)

*   Нашла пример:
```shell
Source: Chongqin_60:27:9d (40:23:43:60:27:9d)
```
Соответствует следующей организации:
```shell
~$ sudo ./oui.sh 40:23:43:60:27:9d  
Для MAC 40:23:43:60:27:9d найдена следующая информация:
402343     (base 16)		CHONGQING FUGUI ELECTRONICS CO.,LTD.
				Building D21,No.1, East Zone 1st Road,Xiyong Town,Shapingba District
				Chongqing  Chongqing  401332
				CN
```

