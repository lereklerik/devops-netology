# Домашнее задание к занятию "3.7. Компьютерные сети, лекция 2"

## 1. На лекции мы обсудили, что манипулировать размером окна необходимо для эффективного наполнения приемного буфера участников TCP сессии (Flow Control). Подобная проблема в полной мере возникает в сетях с высоким RTT. Например, если вы захотите передать 500 Гб бэкап из региона Юга-Восточной Азии на Восточное побережье США. Здесь вы можете увидеть и 200 и 400 мс вполне реального RTT. Подсчитайте, какого размера нужно окно TCP чтобы наполнить 1 Гбит/с канал при 300 мс RTT (берем простую ситуацию без потери пакетов). Можно воспользоваться готовым калькулятором. Ознакомиться с формулами, по которым работает калькулятор можно, например, на Wiki.

*   `RWIN` (TCP Receive Window) - это объем данных, который компьютер может принять без подтверждения отправителя.
*   `RTT` (Round Trip Time) - это время, которое требуется для отправки пакета данных в пункт назначения, плюс время, которое требуется для подтверждения того, что этот пакет был получен обратно.
*   Пропускная способность сети (`Throughput`) рассчитывается по формуле:        
    `Throughput` <= `RWIN` / `RTT`        
     где **RWIN** - это окно приема TCP, а **RTT** - время приема-передачи для пути.
       >В любой момент времени окно, объявленное принимающей стороной TCP, соответствует количеству свободной принимающей памяти, выделенной для этого соединения. 
        В противном случае возникнет риск отбрасывания полученных пакетов из-за нехватки места.  
        Отправляющая сторона также должна выделить тот же объем памяти, что и принимающая сторона, 
        для лучшей производительности. Это связано с тем, что даже после того, как данные были отправлены по сети, 
        отправляющая сторона должна удерживать их в памяти до тех пор, пока они не будут подтверждены как успешно полученные, на случай, если их придется повторно передать.
  
*   `RWIN` >= `Throughput` * `RTT`
    
По условиям задачи:

        1 гигабит/сек = 125 000 килобайт/сек
        1 килобайт/сек = 8 * 10**-6 гигабит/сек

*   `RWIN` >= 1Гбит/с * 300 мс = 125000 КБ/с * 0,3 с = **37500 KByte**

*Размер окна, таким образом, равен* **37500 KByte**

*   По расчетам онлайн-калькулятора ([calculate](https://bikepower.ddns.net/index.php/s/qPHtk5AxKPNJqTf)):
    *   `Theoretical network limit`
        rough estimation: rate < (MSS/RTT)*(C/sqrt(Loss)) [ C=1 ] (based on the Mathis et.al. formula)
        network limit (MSS 1460 byte, RTT: 300.0 ms, Loss: 10<sup><small>-8</small></sup> (10<sup><small>-6</small></sup>%)) : **389.33 Mbit/sec.**
        
    *   `Bandwidth-delay Product and buffer size`
        +   **BDP (1000 Mbit/sec, 300.0 ms)** = **37.50 MByte**
        +   required **tcp buffer** to reach 1000 Mbps with RTT of 300.0 ms >= **36621.1 KByte**
        +   maximum **throughput** with a TCP window of 37500 KByte and RTT of 300.0 ms <= **1024.00 Mbit/sec.**

## 2. Во сколько раз упадет пропускная способность канала, если будет 1% потерь пакетов при передаче?

*   Когда в сети происходит потеря пакетов, на соединение накладывается дополнительный предел. 
    В случае потери пакетов от легкой до умеренной, когда скорость TCP ограничена алгоритмом предотвращения перегрузки, 
    предел можно рассчитать по формуле: 
    
    `Throughput` <= `MSS` / (`RTT`&radic; P<sdown><small>loss</small></sdown>),
     
    где **MSS** - максимальный размер сегмента, а **P<sdown><small>loss</small></sdown>** - вероятность потери пакета. Если потеря пакетов настолько редка, что окно TCP регулярно полностью расширяется, эта формула неприменима. 

*    Если исходить из того, что `MSS` = 1460 байт, то при обращении к онлайн-калькулятору с вводными данными:
       *    **MSS** 1460 byte
       *    **RTT** 300 ms
       *    **Loss** (package loss, P<sdown><small>loss</small></sdown>) 1%
    
Результат будет следующим ([calculate2](https://bikepower.ddns.net/index.php/s/yKCtm5tH3XFFyKg)):            
*   `Theoretical network limit`
    rough estimation: rate < (MSS/RTT)*(C/sqrt(Loss)) [ C=1 ] (based on the Mathis et.al. formula)
    network limit (MSS 1460 byte, RTT: 300.0 ms, Loss: 1%) : **0.39 Mbit/sec**.


Думаю, что я где-то ошиблась... Учитывая, что в 1 задании пропускная способность была рассчитана в **1024,0 МБит/с**, то при 1% потере пакетов
скорость упала больше чем в **2625** раз до **0,39 МБит/с**. 

# 3. Какая максимальная реальная скорость передачи данных достижима при линке 100 Мбит/с? Вопрос про TCP payload, то есть цифры, которые вы реально увидите в операционной системе в тестах или в браузере при скачивании файлов. Повлияет ли размер фрейма на это?

*   Ethernet frame включает в себя:
    *   Ethernet заголовок, 14 байт
    *   IP заголовок, 14 байт
    *   TCP заголовок, 20 байт
    *   Данные пакета (application data)    
    *   Ethernet трейлер, 4 байта

*   Для расчета полезной нагрузки (payload) TCP в сетях Ethernet выделяют также:
    *   `Preamble` – последовательность бит, по сути, не являющаяся частью ETH заголовка определяющая начало Ethernet фрейма (8 байт).
    *   `IFG (Inter Frame Gap)` - Это пауза, которую должно делать передающее устройство перед отправкой фрейма, чтобы избежать коллизий. Длина IFG составляет 12 байт
    *   `FCS (Frame Check Sequences)` – 4байтное значение CRC используемое для выявления ошибок передачи.
    
*   Учитывая, что `MTU` может быть размером от 46 байт до 1500 байт, то:
    *   минимальный размер фрейма = 64 байт
    *   максимальный размер фрейма = 1518 байт
    
**Максимальная полезная нагрузка**: `Max TCP Payload= (MTU–TCP–IP) / (MTU+Ethernet header + Preamble + FCS +IFG)`

*   `MTU` - от 46 до 1500 байт
*   Размер фрейма может находиться в диапазоне от 64 до 1518 байт.

Таким образом:
*   Max TCP Payload для MTU <sdown><small>min</small></sdown>: (46 - 20 - 20) / (46 + 14 + 8 + 4 + 12) = **7.14%** 
*   Max TCP Payload для MTU <sdown><small>max</small></sdown>: (1500 - 20 - 20) / (1500 + 14 + 8 + 4 + 12) = **94.92%** 

Можно сделать вывод, что полезная пропускная нагрузка зависит от величины фрейма.


## 4. Что на самом деле происходит, когда вы открываете сайт? :) На прошлой лекции был приведен сокращенный вариант ответа на этот вопрос. Теперь вы знаете намного больше, в частности про IP адресацию, DNS и т.д. Опишите максимально подробно насколько вы это можете сделать, что происходит, когда вы делаете запрос curl -I http://netology.ru с вашей рабочей станции. Предположим, что arp кеш очищен, в локальном DNS нет закешированных записей.
```shell
~$ curl -I http://netology.ru
HTTP/1.1 301 Moved Permanently
Date: Sun, 27 Jun 2021 15:58:10 GMT
Connection: keep-alive
Cache-Control: max-age=3600
Expires: Sun, 27 Jun 2021 16:58:10 GMT
Location: https://netology.ru/
cf-request-id: 0aefca621b00007b23da2a9000000001
Server: cloudflare
CF-RAY: 665fe01698fe7b23-DME
alt-svc: h3-27=":443"; ma=86400, h3-28=":443"; ma=86400, h3-29=":443"; ma=86400, h3=":443"; ma=86400
```
*   И попробовала вывод с `-v`:
```shell
:~$ curl -v http://netology.ru
* Rebuilt URL to: http://netology.ru/
*   Trying 104.22.49.171...
* TCP_NODELAY set
* Connected to netology.ru (104.22.49.171) port 80 (#0)
> GET / HTTP/1.1
> Host: netology.ru
> User-Agent: curl/7.58.0
> Accept: */*
> 
< HTTP/1.1 301 Moved Permanently
< Date: Sun, 27 Jun 2021 16:13:53 GMT
< Transfer-Encoding: chunked
< Connection: keep-alive
< Cache-Control: max-age=3600
< Expires: Sun, 27 Jun 2021 17:13:53 GMT
< Location: https://netology.ru/
< cf-request-id: 0aefd8c559000014981ca6a000000001
< Server: cloudflare
< CF-RAY: 665ff71bbfc31498-DME
< alt-svc: h3-27=":443"; ma=86400, h3-28=":443"; ma=86400, h3-29=":443"; ma=86400, h3=":443"; ma=86400
< 
* Connection #0 to host netology.ru left intact
```
Подробнее:
1. Происходит поиск соответствия имени хоста и IP-адреса по имени `netology.ru`:
   1. Сначала осуществляется попытка поиска адреса в ОС
   2. Если не найдено в ОС, осуществляется поиск в кэше роутера
   3. Если не найдено, осуществляется запрос к клиентскому DNS (провайдер). Если не найдено, то:
        1. Осуществляется запрос на корневой DNS, перенаправление на `ru` (днс - **LISTEN**)
        2. Запрос на `ru`, перенаправление на `netology`(сервер - **LISTEN**)
        3. Запрос у `netology` - получили IP-адрес (сервер **ESTABLISHED**).
        4. Закэшировали IP-адрес
1. Запрос на подключение к `netology.ru` по 80 порту, устанавливается соединение (**SYN-SENT**)
1. Подтверждение/открытие соединения (мы **SYN-RECEIVED**, сервер - **ACK**)
1. Отправка GET http-запроса, ожидание ответа от сервера (мы **SYN-RECEIVED**, сервер - **ACK**)
1. Получение ответа от сервера (сервер **SYN-RECEIVED**, получаем **ACK**)
1. Подтверждение получения ответа (мы отвечаем **ACK**, сервер **ESTABLISHED**)
1. Запрос на закрытие соединения (**FIN**) `Здесь можно расписать подробнее о закрытии соединения, но очень подробно было описано в предыдущем ДЗ` 
1. Подтверждение закрытия (**FIN**)
1. Подтверждение закрытия (**CLOSED**)


## 5. Сколько и каких итеративных запросов будет сделано при резолве домена www.google.co.uk?

1. Запрос к клиентскому DNS, перенаправление на корневой DNS сервер
2. Корневой DNS перенаправляет на зону UK
3. DNS зоны uk перенаправит на зону CO.UK
4. DNS зоны co.uk перенаправляет на google.co.uk
5. DNS google.co.uk вернет IP-адрес через клиентский DNS клиенту

Получается, 5 запросов

## 6. Сколько доступно для назначения хостам адресов в подсети /25? А в подсети с маской 255.248.0.0. Постарайтесь потренироваться в ручных вычислениях чтобы немного набить руку, не пользоваться калькулятором сразу.

*   **/25** - 255.255.255.1 - каждый октет по 8 бит, последний остался равным 7 бит
*   Чтобы выяснить максимальное количество хостов, надо возвести двойку в степень, равную оставшимся битам, и после - вычесть 2 (служебные адреса 0 и 255):
    *   **Host count** = 2<sup><small>7</small></sup> - 2 = **126**
    *   Количество хостов = 126
*   255.248.0.0 занимает 13 бит (**/13**), значит в остатке для хостов остается **19 бит**
    *   **Host count** = 2<sup><small>19</small></sup> - 2 = **524286**
    *   Количество хостов = 524286
    
## 7. В какой подсети больше адресов, в /23 или /24?

*   Исходя из предыдущего примера с решением, в той подсети, где **меньше отведено бит под маску**:
    *   **/23** - 255.255.254.0, в остатке 9 бит:
        *   **Host count** = 2<sup><small>9</small></sup> - 2 = **510**
    *   **/24** - 255.255.255.0, в остатке 8 бит:
        *   **Host count** = 2<sup><small>8</small></sup> - 2 = **256**
    
## 8. Получится ли разделить диапазон 10.0.0.0/8 на 128 подсетей по 131070 адресов в каждой? Какая маска будет у таких подсетей?

*   **/8** - маска 255.0.0.0, остается **24** бита

| Маска десятичная  | 255       | 0        | 0         | 0         |
:------------------:|:---------:|:--------:|:---------:|:----------|
| Адрес десятичный  | 10        | 0        | 0         | 0         |
| Маска двоичная    | 11111111  | 00000000 | 00000000  | 00000000  |
| Адрес двоичный    | 00001010  | 00000000 | 00000000  | 00000000  |
| Сетевая часть     | nnnnnnnn  |          |           |           |
| Хостовая часть    |           | hhhhhhhh | hhhhhhhh  | hhhhhhhh  |
| Адрес сети двоич. | 00001010  | 00000000 | 00000000  | 00000000  |
| IP-адрес сети     | 10        | 0        | 0         | 0         |
| Обратная маска дв.| 00000000  | 11111111 | 11111111  | 11111111  |
| Обратная маска    | 0         | 255      | 255       | 255       |
| Широковещат.адрес | 10        | 255      | 255       | 255       |
| IP первого хоста  | 10        | 0        | 0         | 1         |
| IP последн. хоста | 10        | 255      | 255       | 254       |

*   **Host count** = 2<sup><small>24</small></sup> = **16777216**, служебные не вычитаем
*   Если учитывать, что в 128 подсетях должно быть по 2 служебных адреса, то в общей сложности служебных адресов должно быть 256
*   Посчитаем, поместится ли в каждую подсеть 131070 адресов и общая сумма служебных: (128 * 131070) + 256 = 16777216

**Да, разделить диапазон получилось**

Маска подсети подсчитана будет следующим образом:
*   128 подсетей - это 2<sup><small>7</small></sup>
*   Префиксом был **/8**, к нему необходимо прибавить выделенные 7 бит для новых подсетей
*   **/15** - новая маска подсети, т.е. 255.254.0.0